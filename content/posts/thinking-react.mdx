---
title: Building React - Color Picker Component
date: 2019-12-04
---

import { CodeWave } from "gatsby-theme-waves"
import {ColorPicker} from "../../src/components/ColorPicker"

*By Danine Noble and David Bergeron*


Hello, My name is David, and that other author over there is Danine. 
Together, we are going to be breaking down and building a React component. On the
menu today we have everyone's favorite UI widget: **The Color Picker**.

Here's the plan:

1. First, we're going to pull apart all the little pieces that you find in a color picker.
2. Then, piece by piece, we're going to build the component.
3. Last, but certainly not least we will pick some *groovy* colors.


<CodeWave>

```jsx
const ColorPicker = () => (
  <>
  </>
  )
```

## The Pieces

To get us started we tried to find the major parts involved in a color picker. 
We are going to need:

- A visual representation of the color choices
- A way to grab user input.
- A presentational component to display our results (show which color the user has selected).



```jsx
const ColorPicker = () => (
    <>
      <div>
        <Map />
        <Slider />
      </div>

      <ColorDisplay />
    </>
  )
```
We have isolated these into three separate components: **Map** and **Slider** to get our user input,
 **ColorDisplay** to output our results. Our Map will allow the user to click on a color, 
  our Slider will provide an additional way to control the color options available, and the 
  ColorDisplay will show off the pretty results.
 
 At this point you might be tempted to jump right
 into building one of the smaller components. This decision 
 will lead to some problems: data in React only
 flows one way, from the top to the bottom. We need to do some 
 thinking up front  about how information is going to 
 be passed through our app. What values will be changing?
  Which components need to know about each other? In other words, we need to do some thinking about...

 ## State

 
 Let's take a step back: what are we trying do to? The end goal is a color value we can display to
 the user in whatever format we desire. So how do we get that 
 color value? First we have to decide on an initial format: 
 We've chosen to represent color using HSL/HSV. The user will need
 some way to supply Hue, Saturation and Lightness values. 
 Once we have our HSL/HSV color, we can convert it to 
 whatever format we want. 

A good place to start is our user input. In our scenario, we are 
taking in input from two components: Our **Slider** and our **Map**. 
We are using the **Slider** to control our Hue value, and we are
using the last-clicked X and Y position to control Saturation and Lightness.

In order to feed these inputs to the right place, its important
that we keep our state at the *top-level* of our component.

```js
const ColorPicker = ({ width, height }) => {
  // This controls our Hue
  const [sliderVal, setSliderVal] = useState(150)
  // This controls our Saturation and Lightness.
  const [pointPos, setPointPos] = useState([width / 2, height / 2])
  // This color state represents the final color result.
  const [color, setColor] = useState(tinycolor())

  return (
    <>
      <div>
        <Map />
        <Slider />
      </div>

      <ColorDisplay />
    </>
  )
}
  
```

Additionally, we are going to find it useful to pass our color around,
so we add an additonal Color state, the currently calculated color value.
We are using the library [tinycolor2](http://bgrins.github.io/TinyColor/)
to handle all of our color values, so we make sure to initialize the color
state to the format tinycolor2 is looking for.

On that note, it's important we intialize our state with good "starter" values. This
way our pointer starts at the middle of the color map, and the hue
doesn't start at one of the extremes.

So to recap, here are our three states:

- sliderVal: the hue determined by Slider
- pointPos: the position of the pointer on the Map
- color: the final color value derived from the pointer position and hue

```js
const ColorPicker = ({ width, height }) => {
  const [sliderVal, setSliderVal] = useState(150)
  const [pointPos, setPointPos] = useState([width / 2, height / 2])

  return (
    <>
      <div>
        <Map />
        <Slider />
      </div>

      <ColorDisplay />
    </>
  )
  }
  
```

### SliderVal

SliderVal is set by the Slider component,
which then gets passed to the Map and sets its background color.
We built our Slider component out of the basic HTML Range Slider. 
Some of the alternative implementations we looked into had code over
*10,000* lines long to build a slider. Thank goodness that comes built
in these days.

```js 2,12,15
const ColorPicker = ({ width, height }) => {
  const [sliderVal, setSliderVal] = useState(150)
  const [pointPos, setPointPos] = useState([width / 2, height / 2])
  const [color, setColor] = useState(tinycolor())
  
  return (
    <>
      <div style={{ display: "flex" }}>
        <Map
          width={width}
          height={height}
          bgColor={`hsl(${sliderVal}, 100%, 50%)`}
          dragging={movePointer}
        />
        <Slider value={sliderVal} setValue={setSliderVal} height={height} />
      </div>

      <ColorDisplay color={color} />
    </>
  )
}
```
### pointPos

As we mentioned, we use the pointer's position to control 
our saturation and lightness. When the user clicks or drags along
our color map, we lift up the X/Y coordinates, which we use
 to build our...


```js 3,6:8,17
const ColorPicker = ({ width, height }) => {
  const [sliderVal, setSliderVal] = useState(150)
  const [pointPos, setPointPos] = useState([width / 2, height / 2])
  const [color, setColor] = useState(tinycolor())

  const movePointer = (x, y) => {
    setPointPos([x, y])
  }
  
  return (
    <>
      <div style={{ display: "flex" }}>
        <Map
          width={width}
          height={height}
          bgColor={`hsl(${sliderVal}, 100%, 50%)`}
          dragging={movePointer}
        />
        <Slider value={sliderVal} setValue={setSliderVal} height={height} />
      </div>

      <ColorDisplay color={color} />
    </>
  )
}
```

### Color

Whenever the user changes an input, we want our color value to update.
This is easy with React Hooks!

Note our usage of useEffect here: we've listed our input states
as dependencies. Because we've lifted our state up to the same level
as as the useEffect call, we can watch those values for changes.

Then, whenever something changes, bake me a new color baby!

So wait a minute... how do we actually DO any of that? What do our 
individual components look like? Surely we must be hiding
10,000 lines of extra javascript *somewhere* right?

let's dive a little deeper into each component.

```js 4,10:25,39
const ColorPicker = ({ width, height }) => {
  const [sliderVal, setSliderVal] = useState(150)
  const [pointPos, setPointPos] = useState([width / 2, height / 2])
  const [color, setColor] = useState(tinycolor())

  const movePointer = (x, y) => {
    setPointPos([x, y])
  }

  useEffect(() => {
    function updateColor() {
      const [xPos, yPos] = pointPos

      const h = sliderVal
      const s = xPos / width
      const v = 1 - parseFloat(yPos) / (height - 1)

      const c = tinycolor({ h, s, v })
      setColor(c)
    }

    if (color) {
      updateColor()
    }
  }, [sliderVal, pointPos, width, height])
  
  return (
    <>
      <div style={{ display: "flex" }}>
        <Map
          width={width}
          height={height}
          bgColor={`hsl(${sliderVal}, 100%, 50%)`}
          dragging={movePointer}
        />
        <Slider value={sliderVal} setValue={setSliderVal} height={height} />
      </div>

      <ColorDisplay color={color} />
    </>
  )
}
```


```js
const Slider = ({ value, setValue, height }) => {
  const handleChange = e => {
    setValue(e.target.value)
  }

  let origin = height / 2 - 5

  return (
    <div className="slider-wrapper">
      <input
        type="range"
        id="range"
        min="0"
        max="360"
        step="1"
        value={value}
        onChange={handleChange}
        style={{ width: height, transformOrigin: `${origin}px ${origin}px` }}
      />
    </div>
  )
}
```

## The Slider Component

*stuffs*

```js
const Map = ({ width, height, bgColor, dragging }) => {
  return (
    <div className="map" style={{ width, height }}>
      <div className="color-bg" style={{ backgroundColor: bgColor }}>
        <div className="overlay" />
      </div>
      <Draggable
        bounds="parent"
        defaultPosition={{ x: width / 2, y: height / 2 }}
        onDrag={(e, data) => dragging(data.x, data.y)}
      >
        <div className="pointer"></div>
      </Draggable>
    </div>
  )
}
```

## The Map Component

*stuffs*

```js
const ColorDisplay = ({ color }) => {
  if (color) {
    let hex = color.toHexString()
    let hsl = color.toHslString().slice(4, -1)
    let rgb = color.toRgb()

    return (
      <div className="color-display">
        <div className="color-preview" style={{ backgroundColor: hex }}></div>
        <div>
          <div>HEX</div> {hex}
        </div>
        <div>
          <div>RGB</div>
          {rgb["r"]}, {rgb["g"]}, {rgb["b"]}
        </div>
        <div>
          <div>HSL</div>
          {hsl}
        </div>
      </div>
    )
  } else {
    return null
  }
}
```

## The Color Display Component
*stuffs*

</CodeWave>

Of course this project wouldn't be complete without the final color picker.

<ColorPicker width={627} height={300} />

*This project has been built with [Gatsby JS](https://www.gatsbyjs.org/) using the theme: [Gatsby Waves](https://www.gatsbyjs.org/packages/gatsby-theme-waves/).
 If you're interested in how we put it all together you can [check out our code on github](https://github.com/SceptreData/double-d-react). *